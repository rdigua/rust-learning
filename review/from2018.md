# Review daily news (2018)

## game

### Amethyst

1. Amethyst 0.7 发布 (jay)

Amethyst 是Rust实现的游戏引擎，采用了ECS架构，0.7版本使用specs

[原文](https://www.amethyst.rs/2018/05/18/blog.html)

2. 数据驱动游戏引擎Amethyst 发布0.8

发布了新的指南，以及巨量新特性

该引擎特色：

-   使用gfx-rs渲染OpenGL图形，支持2D和3D，不久会支持Vulkan和Metal
-  使用严格的Entity Component System (ECS)架构来组织游戏逻辑。可能是世界上最快的ECS，无运行时反射，可以毫不费力地处理数百万个组件
- 跨平台，当前支持Windows/Linux/Mac，马上会支持iOS和Android

- [原文](https://www.amethyst.rs/blog/release-0-8/)
- [官网](https://www.amethyst.rs/)

3. 游戏引擎Amethyst基准测试

以60fps渲染尽可能多的 bunny sprites 来对Amethyst做基准测试

```
Results

Command                      Bunnies Rendered
-----------------------------------------------------
cargo run                       |         3,400
cargo run --release    |         109,800

```

看看release和debug的差距

[amethyst-bunnymark](https://github.com/cart/amethyst-bunnymark)

4. Amethyst游戏引擎的最新进展

开发团队：

- 组建核心团队，负责整体管理和方向。
- 引入新的贡献者团队，这些团队专注于引擎的特定领域，并授权写入权限。
- 引入活跃策略。如果团队中有人在6个月内处于非活跃状态，将会被自动剔除团队。
-  现在有四名活跃的成员。

引擎核心：

- 基于UDP协议的net-dev正在取得进展，它会独立于引擎之外，但会被用于引擎中的高级API。这意外着你可以独立使用net-dev库。
-  3D渲染器正在完全重写，为了支持现代的渲染技术（Vulkan/Metal/DirectX12后端、VR等），正在招募相关经验的贡献者
-  正在设计和原型化支持高级部署体系结构的新的资源管道，有助于集成专业级的工作流到引擎中。（使用构建时和部署时配置来节省运行时的计算负担），并减少开发人员和艺术家的资源管理负担。希望通过引擎实现高度可扩展的开发流程，即使在大型商业游戏上也是如此。
- 实验性的Amethyst editor 发布，用于创建游戏原型
- 下一步将推出0.9版本，该版本将助力于2D游戏开发人员

[原文](https://www.amethyst.rs/blog/dev-news-10-2018/)

5. 「游戏」Amethyst 0.9发布

- 改进了2D流程
- 引入了新的DrawSprite方法，60FPS可以绘制10w个精灵
-  增强了网络系统
-  实验性的编辑器支持，基于Electron构建
[Read More](https://www.amethyst.rs/blog/release-0-9/)

6. 「社区」amethyst开源游戏引擎创建了RFC仓库

关键字: [amethyst, rfc]

[rfcs](https://github.com/amethyst/rfcs)

7. Amethyst V0.10发布

#game #amethyst

在发布文章里还描述了2019年计划。

[Read More](https://www.amethyst.rs/blog/release-0-10/)

8. 「小游戏」 使用Amethyst引擎实现的经典游戏Asteroids

#asteroids #amethyst #ecs #rust2018

基于Rust 2018 版本

[asteroids-amethyst](https://github.com/udoprog/asteroids-amethyst)

9. 「游戏」Amethyst基金会成立了

#amethyst #game

好消息。Amethyst是一款免费的开源游戏引擎。它是用Rust编写的，其核心是ECS架构。现在成立了基金会是为了组建一个官方的非盈利组织。这对于Amethyst的发展应该是非常有好处的了。当然，现在的状态只是提交了文件，还在等待最后的审批。

[Read More](https://www.amethyst.rs/blog/non-profit-announce/)

10. 「视频」使用Rust和Amethyst引擎进行游戏开发 (jay)

#amethyst #game

视频演讲中以一个开源的消除游戏everpuzzle为示例进行介绍。 [大约1小时]

[everpuzzle Code](https://github.com/Skytrias/everpuzzle)

[Read More](https://www.youtube.com/watch?v=P_9A7P0uNpY)

11. 「小游戏」 使用Amethyst引擎实现的经典游戏Asteroids

基于Rust 2018 版本

[asteroids-amethyst](https://github.com/udoprog/asteroids-amethyst)

12. Rust游戏工作组的简单议程

#game

提议将Amethyst作为旗舰项目。此议程应该是非官方发起的。(jay)

[Read More](https://medium.com/rustgamedev/a-simple-agenda-for-the-rust-game-development-wg-485cfc72b088)

13. 「游戏」Amethyst基金会成立了

好消息。Amethyst是一款免费的开源游戏引擎。它是用Rust编写的，其核心是ECS架构。现在成立了基金会是为了组建一个官方的非盈利组织。这对于Amethyst的发展应该是非常有好处的了。当然，现在的状态只是提交了文件，还在等待最后的审批。

[Read More](https://www.amethyst.rs/blog/non-profit-announce/)

<Jay> It can be trying.

### 使用Rust来编写一个文字游戏

[lets build zork using Rust](https://dev.to/mindflavor/lets-build-zork-using-rust-1opm)

zork是最早的有名的一款文字游戏，中文好像叫《魔域》。 文章里主要侧重于Rust编写一个状态机，也可以从中学到一些用Rust编写代码的思路，学习Rust Style。

### 在Android游戏中使用SDL2

文中提到 https://github.com/tomaka/ 写了很多android使用Rust需要的工具，比如android-rs-glue

- [原文](https://lliwynd.blogspot.ca/2018/05/rust-for-android-games-using-sdl2.html)
- [rust-sdl2](https://github.com/Rust-SDL2/rust-sdl2)

<jay> Watching and trying it.

### 【重磅】开发《战神》的游戏大厂宣布将全面拥抱Rust

曾开发 《战神：奥林匹斯之链》 和《 战神：斯巴达之魂》 的业界大厂 Ready at Dawn Studios 日前表示，将放弃C/C++开发，全面拥抱Rust。

其CTO表示：将使用Rust添加或替换掉核心技术模块，最初会使用C-API来和遗留代码集成，直到最终不再有遗留代码。

> 老实说，我不再认为有任何理由使用C++

![img](https://wx2.sinaimg.cn/mw690/71684decly1ftkqg72dmej20qi0f0401.jpg)
![img](https://wx2.sinaimg.cn/mw690/71684decly1ftkrcoc8csj20zg07umzm.jpg)

---

## ***模拟器***


### 一个NES模拟器

（Rust + WebAssembly +  stdweb crate ），可以用浏览器玩NES游戏了。

注意要使用Firefox最新版打开，Chrome暂时不支持

[http://koute.github.io/pinky-web/](http://koute.github.io/pinky-web/)

### 又是 waaaaaaaaaaaaaasm

新的 wasm 内存分配器介绍

[wee alloc](http://fitzgeraldnick.com/2018/02/09/wee-alloc.html)

Rust+WASM写的NES模拟器

[rustynes](https://github.com/bokuweb/rustynes)

[相关博文（日语）](http://blog.bokuweb.me/entry/2018/02/08/101522)

### Rust写的量子计算机模拟器

Rust+OpenGL ，怕不怕？

[QCGPU](https://qcgpu.github.io/)

###  rust + wasm实现nes模拟器

[原文](https://medium.com/@bokuweb17/writing-an-nes-emulator-with-rust-and-webassembly-d64de101c49d)

### 致敬经典： Chip8模拟器的Rust实现

[chip8](https://github.com/shiver/chip8)

### 用Rust实现的Erlang运行时（BEAM模拟器）

[ErlangRT](https://github.com/kvakvs/ErlangRT)

### 在gfx-portability的Metal后端上运行RPCS3和Dolphin

- RPCS3是一个开源的Sony PlayStation 3仿真器，经过gfx-rs团队的努力，现在可以在RPCS3中渲染游戏。
- Dolphin是最近两款任天堂视频游戏机的模拟器：GameCube和Wii。

[原文](https://gfx-rs.github.io/2018/09/03/rpcs3-dolphin.html)

---

## learning



### 《Rust 异步编程》 官方教程 出炉了

[《Rust 异步编程》 官方教程](https://rust.cc/article/70a03f2b-6d16-4ea2-aa0c-3fb130aa1b51)

感谢无私的野喵

### NewRustacean ： Diesel的过去和现在

[Diesel的过去和现在](http://www.newrustacean.com/show_notes/interview/diesel_1_0/part_1/index.html)

NewRustacean让我大开眼界：还有这种操作？

[new rustacean](http://www.newrustacean.com/show_notes/index.html)

利用Rust的文档功能写教程做网站！

好吧，是贫穷限制了我的想象力。
### Gstreamer Rust绑定使用教程

[Gstreamer介绍](https://www.ibm.com/developerworks/cn/aix/library/au-gstreamer.html)

[How to write GStreamer Elements in Rust Part 1: A Video Filter for converting RGB to grayscale](https://coaxion.net/blog/2018/01/how-to-write-gstreamer-elements-in-rust-part-1-a-video-filter-for-converting-rgb-to-grayscale/)

### 给Java开发者写的Rust入门介绍之创建变量

[原文链接](https://lankydanblog.com/2018/01/13/rust-for-java-devs-creating-variables-first-rust-post/)

### 给C程序员写的Rust 指针教程

[Rust pointer for C programmer](http://blahg.josefsipek.net/?p=580)

### 给萌新的lifetime教程

来自德国创业公司ASQ CEO的文章。

该公司使用Rust、Haskell等高逼格语言，之前关注过，工作职位应该是可以远程的，感兴趣的可以关注关注。

[rust lifetimes for the uninitalised](http://asquera.de/blog/2018-01-29/rust-lifetimes-for-the-uninitialised/)

### [教程] 如何使用Rust构建OpenGL渲染器

[原文](https://www.reddit.com/r/rust/comments/92abkg/rust_and_opengl_from_scratch_a_blog_post_series/)

[原文](http://nercury.github.io/rust/opengl/tutorial/2018/02/08/opengl-in-rust-from-scratch-00-setup.html)

### 有没有让你困扰的Rust 2018特性？

可以到这个帖子里写下具体的代码片段

[原文](https://internals.rust-lang.org/t/examples-where-2018-feature-caused-confusion/8067)

### 使用Rust开发静态Web 应用

作者记录了他的Yew和Rust三天之旅

[原文](http://bluejekyll.github.io/blog/rust/2018/07/22/static-web-app-rust.html)

### ralfj： 指针真的很简单只是整数而已吗？

最近回归Rust核心团队的ralfj来帮助你破除这种传言。ralfj正在为mir的内存模型而努力，这篇文章是他对指针模型和思考。主要涉及两个问题：

- 指针是什么
- 内存中的字节是什么

因为他需要在mir中实现，如果指针和字节仅仅是数字，那么可能无法满足他的需求。

结论：

1. 指针绝不是整数。证明：如果两个指针具有相同的地址，并不意味着它们就可以相互交换使用。
2. 指针是什么？其实没有这个问题的完整答案。在Rust中，由miri实现的指针模型是：指针是由“分配资源的唯一标识ID”和“偏移量”组合而成。
3. 字节也不仅仅是0..256范围内的数字。

[原文](https://www.ralfj.de/blog/2018/07/24/pointers-and-bytes.html)

### Cargo中的版本选择

在这篇文章里，Aturon解释了为什么Cargo在解决依赖关系时通常会选择最新版本。

Aturon认为「依赖地狱」出现的原因是以下四点目标没有做好：

- 重复性。在不同的机器上进行构建都会得到相同的结果
- 控制。用户可以控制何时以及如何升级依赖
- 兼容性。
- 可维护性。

因此，包管理的作用就是提供机制、默认值和最佳实践，以便促使生态系统在这些目标之间达成平衡。目前并没有出现一个最佳的解决办法。

最大版本解析的基本原理：

- 大多数包管理器都使用最大（最新）版本，只有vgo使用了最小版本
-  选择最大版本，需要lockfile文件的帮助来实现重现机制，而最小版本则不需要
- 选择最大版本，是促进生态系统一致性的协议：版本之间彼此测试兼容性要以最新版本为准；而选择最小版本，则不会达到生态系统一致的目的。
-  选择最大版本，有利于下游用户获得最新的错误修正，也可以促使生态系统中的库倾向于维护最新版本。
- Cargo团队认为，选最大版本是对整个生态系统有好处的。主要的成本在于lockfile的复杂性。

文章里也有关于工具链的更多讨论：

[原文](http://aturon.github.io/2018/07/25/cargo-version-selection/)

### 讨论： Rust用户可以从C/C++学到什么？

这个帖子评论很多，可以看看

个人观点： Rust用户倒是可以从C/C++那里学到很多教训，反而对Rust的设计理解更深

[原文](https://www.reddit.com/r/rust/comments/90mj0d/what_could_rust_users_learn_from_c_or_c/)

### 教你如何阅读反汇编

有助于Rust的学习

[原文](https://hackernoon.com/you-too-can-read-disassembly-d47a3be74010)

### 基于组件的Rust程序架构模式

本文探索组件模式以及如何在Rust中实现它，从组件trait的基本概念开始，然后基于组件的并行操作，通过消息传递来通信。并且包含一个完整的示例。

大型应用程序通常由许多有状态进程组成，这些进程必须以特定的顺序启动和停止。 组件模型使这些关系显式和声明性，而不是隐式代码。

组件trait：

```rust
#[derive(Debug)]
enum ComponentError {
  NotStarted,
  InvalidConfiguration
}

pub trait Component {
    fn get_name(&self) -> &str;
    fn start(&mut self) -> Result<(), ComponentError>;
    fn stop(&mut self) -> Result<(), ComponentError>;
}

```

[原文](https://vadosware.io/post/a-pattern-for-component-based-program-architecture-in-rust/)

### 关于CTFE和类型系统的思考

CTFE（Compile-Time Function Evaluation），是指编译时函数求值，直白地说，是编译期执行代码。比如，知道了数组的大小如何在编译期计算其内存布局。

从Rust1.26以来Rust引进了CTFE，因此引发了一系列CTFE期间应该允许哪些操作的探讨。这篇文章是从类型系统角度对这些讨论的看法。

CTFE仅用于const的值或者是数组长度

rust
fn demo() {
  const X: u32 = 3 + 4; // CTFE
  let x: u32 = 4 + 3; // no CTFE
}

CTFE需要考虑的问题（要点总结）：

- const安全，并非所有操作都可以在CTFE上下文使用 ，所以需要考虑以下问题：
    - CTFE必须是确定的，也就是说，不能存在歧义，否则会计算错误。
    - const fn 之所以存在，是为了满足在CTFE上下文中调用指定的函数。const fn 关键字可以让编译期识别，以便和普通的fn区分。

- const类型系统和健壮性
    - const类型系统不允许CTFE调用非const函数
   - CTFE不能支持指针，因为在编译期需要合法有效的值，指针无法保证

- CTFE的正确性
    - Rust中CTFE是由miri来执行的，miri是一个mir解释器，已经集成到了rustc中
    -  miri执行const上下文的代码，并且目前，拒绝原始指针的所有操作。但是未来还会计划修改miri来让它执行更多的操作。
   - CTFE的正确性是指编译期求值和运行时的表现完全一致。但是目前CTFE对于浮点数的计算比较困难。

- CTFE与Unsafe（假如扩展miri来支持unsafe，需要允许哪些操作？）
   -  CTFE目前已经实现了以确定的方式支持内存分配
  -  允许引入 const-unsafe来操作原生指针，也就是说，把const上下文也分为safe和unsafe两个区域

- 静态提升（Static Promotion）
    -  比如，`fn make_a_3() -> &'static i32 { &3 }` 返回值 包含的&3会被提升为一个静态值，从而编译通过。
   - 应该只允许遵循const-well-type的值进行静态提升，比如`&3`可以提升，而`*const T`不行
  - 要保证CTFE的正确性

看来，CTFE还有很长一段路要走啊，想利用miri来检测unsafe中的UB比我想象中困难

[原文](https://www.ralfj.de/blog/2018/07/19/const.html)


### 对Rust crate依赖的理论化研究

这个仓库里包含了一篇论文，研究了依赖的兼容性

[原文](https://github.com/teiesti/compdep)

### 为什么你应该经常练习防御性编程？

Rust只能保证所有权可以控制范围内的安全。作者举了一个逻辑错误的示例来说明这一点。

建议：

- 写代码的时候要预估错误
- 识别事务中最基本的工作单元（比如某个任务的具体步骤、缩略图中的单个缩略图、下载器中的单个文件等），并为其定义可能产生的意外错误

[原文](http://blog.ssokolow.com/archives/2018/07/17/why-you-should-always-practice-defensive-programming/)

### Rust中如何实现高阶函数？

作者对目前Rust支持高阶函数的几种用法做出了探索和总结，从侧面也展示了impl Trait、HRTB、FnBox等存在的意义和局限

[原文](http://phaazon.net/blog/rank-n-rust)

### 如何在编译时防止SQL注入

[原文](https://polyfloyd.net/post/compile-time-prevention-of-sql-injections/)

### 使用Rust实现一个简单的Datalog引擎： Datafrog

[datafrog](https://github.com/frankmcsherry/datafrog)

Datalog是一种基于逻辑的编程语言。

[blog]( https://github.com/frankmcsherry/blog/blob/master/posts/2018-05-19.md)

### 「博文」Rust错误处理

#error_handle

[Read More](https://medium.com/learning-rust/rust-error-handling-72a8e036dd3)

### 学习Rust的泛型

[原文](https://tutorialedge.net/rust/learning-generics-in-rust/)

### Learning Rust  

Github Page页面上线。 [Learning Rust](https://learning-rust.github.io/docs/a1.why_rust.html)



### 完全使用Rust编写Web应用的经验和教训 

此文是作者对Webapp.rs项目过去四个月的总结，结论就是，该项目的状态可以为想使用Rust进行全栈Web开发的用户提供了一个良好的开端。

[原文](https://medium.com/@saschagrunert/lessons-learned-on-writing-web-applications-completely-in-rust-2080d0990287)

[webapp.rs](https://github.com/saschagrunert/webapp.rs)

<Jay> learning.

### 「博文」学习Rust，痛并快乐着

此文是influxdata的开发者写的，他是一名Go程序员，然后最近开始学习Rust。本文记录了他的一些学习心得和过程。

他学习过程不仅仅是看书，Go社区有本书叫[《用Go实现解释器》](https://interpreterbook.com/)，这本书里实现了一个语言，叫做Monkey 语言。然后他本身是Go程序员，所以在学习Rust的时候，通过这本书，用Rust实现了Monkey语言，文中有源码仓库地址。

[ Read More ](https://www.influxdata.com/blog/rust-can-be-difficult-to-learn-and-frustrating-but-its-also-the-most-exciting-thing-in-software-development-in-a-long-time/)

<Jay> learning.

### 处理Rust异步流的小技巧：

[Rust Stream Terminate](http://xion.io/post/code/rust-stream-terminate.html#rust-stream-terminate)

--

## series

### withoutboats 创作的Async/Await系列博文

withoutboats是官方核心团队人员，以下是第一篇，大家可以关注

[Async/Await I: Self-Referential Structs](https://boats.gitlab.io/blog/post/2018-01-25-async-i-self-referential-structs/)


### 官方人员withoutboats Async/Await 教程第二部分

[Async/Await II: Narrowing the Scope of the Problem](https://boats.gitlab.io/blog/post/2018-01-30-async-ii-narrowing-the-scope/)

### Async/Await 系列第三篇

[Async/Await III](https://boats.gitlab.io/blog/post/2018-01-30-async-iii-moving-forward/)


### async系列文章IV

[async 系列 iv](https://boats.gitlab.io/blog/post/2018-02-07-async-iv-an-even-better-proposal/)


### async/await系列文章V

[async V](https://boats.gitlab.io/blog/post/2018-02-08-async-v-getting-back-to-the-futures/)

### 用Rust写一个操作系统系列文章

- [第二版](https://os.phil-opp.com/second-edition/)
- [GitHub仓库](https://github.com/phil-opp/blog_os)


### 用Rust写OS系列文章：集成测试

该篇介绍如何实现一个简单的集成测试框架，在QEMU虚拟机的实例中运行集成测试。

[原文](https://os.phil-opp.com/integration-tests/)


### 用Rust写操作系统系列文章： CPU异常

[原文](https://os.phil-opp.com/cpu-exceptions/)


### 「用Rust写操作系统V2系列」硬件中断

本篇介绍了如何用Rust处理硬件中断，将学习到如何获取定时器中断周期以及如果从键盘获取输入。

也能看到Rust的所有权对写操作系统产生什么有益的助力。

[Read More](https://os.phil-opp.com/hardware-interrupts/)

### 系列文章：在JS web开发中使用Rust模块

[Using rust modules in JavaScript/Web Development](https://medium.com/@atulanand94/using-rust-modules-for-javascript-web-development-part-i-e6dec27df7b2)

###  嵌入式开发

-  作者准备写Rust嵌入式开发方法的一系列文章，可以关注
	- [embbedded rust why](http://ithinuel.me/embedded-rust-why/)
-  ARM Cortex-M开发不再需要Xargo了，(nightly-2018-04-08) 版本的Rust包含了最新的compiler_builtins组件来替代
	- [PSA: You no longer need Xargo to do ARM Cortex-M development](https://users.rust-lang.org/t/psa-you-no-longer-need-xargo-to-do-arm-cortex-m-development/16703)
-  Moonfire NVR是一款开源的安全网络视频录制库，支持树莓派2
	- [moonfire-nvr](https://github.com/scottlamb/moonfire-nvr)


###  Niko准备写一系列关于Rust编译器错误的文章

目的是尝试解释这些错误背后的逻辑，并给出一些可以避免这些错误的模式，这是系列的第一篇，利用Rc来解决错误

[rust pattern rooting an rc handle](http://smallcultfollowing.com/babysteps/blog/2018/04/16/rust-pattern-rooting-an-rc-handle/)


### 如何用Rust优化js代码系列文章  Part1

[How To Optimize JavaScript Code with Rust Part 1](https://codeburst.io/how-to-optimize-javascript-code-with-rust-part-1-20f00885608f)


### 「系列文章 Rust on Azure Functions Part 4」使用Rust和Wasm提升JavaScript 10倍速

更具体来说，该文涉及：

- wasm
- azure Functions
- 遗传算法
- 快速解决复杂的优化问题

[前文「使用 rust+wasm提升Azure’s FaaS 性能的可能性」链接](https://t.me/rust_daily_news/640)

[Read More ](https://blog.x5ff.xyz/blog/azure-functions-wasm-rust-ai/)


### Rust模式系列文章第二篇： 明确闭包捕获条件

给出了一种通用的模式来明确闭包捕获的条件，避免错误。

[原文](http://smallcultfollowing.com/babysteps/blog/2018/04/24/rust-pattern-precise-closure-capture-clauses/)

### Rust嵌入式开发日志系列文章

使用 [rust-bitfield]( https://github.com/dzamlo/rust-bitfield ) 来访问外设寄存器

[原文](https://ithinuel.me/embedded-rust-peripherals-take-1/)


### 「非官方」Cargo的未来系列文章Part2： 将Rustup集成到Cargo的一些思考

这样做是为了减少手动的步骤，让开发人员可以统一工具链、cargo版本等。

[原文](https://medium.com/@tibotz/embedding-rustup-into-cargo-and-the-wrapper-d5b447f381fc)


### IBM developerworks上新手指南系列文章：了解Rust

[原文](https://www.ibm.com/developerworks/opensource/library/os-know-rust/index.html)

### 使用Rust写一个Web API 客户端系列文章 Part 2

[原文](https://theomn.com/rust-web-api-client-part-02/)


### Learning Rust 系列博客 Part II

使用sqlite和diesel框架

[原文](https://medium.com/@rippinrobr_66849/2-conspiracies-databases-and-diesel-rs-ac1d8d3499b3)


### Rust并发模式系列文章

- [rust-concurrency-patterns-communicate-by-sharing-your-sender](https://medium.com/@polyglot_factotum/rust-concurrency-patterns-communicate-by-sharing-your-sender-11a496ce7791)
- [rust-concurrency-patterns-natural-born-pipelines](https://medium.com/@polyglot_factotum/rust-concurrency-patterns-natural-born-pipelines-4d599e7612fc)
- [rust-concurrency-patterns-no-context-no-cancel-no-leak](https://medium.com/@polyglot_factotum/rust-concurrency-patterns-no-context-no-cancel-no-leak-b6c1ec2dafa5)

### 官方人员系列博文：async  方法 PartI

```rust
trait Foo {
    async fn foo_method(&self) -> i32;
}
```

async方法有望在7月份加入nightly版本试用

[原文](https://boats.gitlab.io/blog/post/async-methods-i/)


### withboats async方法系列 II：

async 方法和对象安全的关联

[原文](https://boats.gitlab.io/blog/post/async-methods-ii/)


### 从Go到Rust系列文章第二部分

使用Go建立一个简单的REST服务，然后用Rust来实现它

[原文](http://technosophos.com/2018/06/12/from-go-to-rust-json-and-yaml.html)


### 「系列文章」Rust vs Swift

#swift

作者从2015年开始写这一系列博客，直到昨天才发布了一个整理页面。感兴趣可以看看。

[Read More](https://www.chriskrycho.com/rust-and-swift.html)


### `*-sys`系列库使用教程

#C #ffi

`* -sys`是帮助Rust程序使用C（“System”）库的crate命名约定，例如： libz-sys，kernel32-sys，lcms2-sys。 sys crates的任务是向Rust（FFI）公开一个最小的底层C接口，并告诉Cargo如何与库链接。

[Read More](https://kornel.ski/rust-sys-crate)


### 在AWS Lambda上运行Rust的新故事

#lambda #aws

所谓新故事是指作者之前写了一系列在lambda上面跑Rust的文章，那会官方还不支持Rust。现在官方支持了Rust，那么他又针对这一变化，对他之前发布的工具集和思路做了一个更新说明。

[Read More](https://medium.com/@softprops/serverless-rust-revisited-f2c79f4039bb)

### 用Rust实现一个温度计系列文章  Part I

基于resin.io、resionOS和树莓派

[原文](https://www.robertvojta.com/rust-thermometer-part-1/)


### devtop： 命令行解析器

系列文章，该文作者可能是一个运维（多和ansible、python、openstack打交道），正在准备用Rust实现一个运维工具devtop，是对他之前一个工具的重构。

该文主要是记录他处理命令行参数解析的过程

[原文](https://medium.com/journey-to-rust/devtop-command-line-parser-f08b72b02bea)


### HTTP缓存：共享可变状态

属于servo编程系列文章

该文章中介绍了servo中实现HTTP缓存，如何处理共享可变状态

[原文](https://medium.com/programming-servo/programming-servo-an-http-cache-edb52a7f267f)


### NES模拟器开发日志系列文章 Part 2

>到目前为止，Rust已经被证明是模拟器开发的最佳选择，最大的收获是静态检查和编译器错误警告阻止了大多数错误。

[原文](https://medium.com/@ltriant/nes-emulator-part-2-i-sort-of-know-what-im-doing-f64d5e61caed)


### 系列文章：Rust实现一个最小化的容器运行时 2

本文作者以学习Docker的目的，用Rust实现了一个最小化容器运行时

[原文](http://rabbitstack.github.io/operating%20systems/containers/linux-container-internals-part-ii/)

[github](https://github.com/rabbitstack/rabbitc)


### 系列文章： Linux容器内部 Part2

作者用Rust实现了一个微容器rabbitc，文章是相关内容

[原文](https://rabbitstack.github.io/operating%20systems/containers/linux-container-internals-part-ii/)

[rabbitc](https://github.com/rabbitstack/rabbitc)


### Rust实现PCG技术系列博客Part 3

PCG是Procedural Content Generation，一般用于游戏中自动生成内容。

[原文](https://www.jamestease.co.uk/blether/procedural-generation-with-binary-space-partitions-and-rust)


### 学习Rust系列：实现一个ls工具

[原文](https://routley.io/tech/2018/07/08/learning-rust-02.html)


### 所以，你想创建一个语言虚拟机吗？

这是一个系列文章（如果作者足够坚持的话）的第00篇。教你使用Rust构建一个语言的VM。

[原文](https://blog.subnetzero.io/post/building-language-vm-part-00/)

一共出到了第四篇：[原文](https://blog.subnetzero.io/)

事实上，也可以看看比较成熟的相关项目源码，比如 [inko](https://inko-lang.org/ )， inko就是用Rust实现了一个VM，一门面向对象语言，还支持类Erlang轻量级进程来处理并发。


### PRRR全栈开发 系列文章Part 2

第一篇文章之前介绍过： https://medium.com/@ccrsh/introducing-prrrstack-d617ff518ba6

PRRR是指Postgresql、Rust、Rocket、React 进行全栈Web开发

[原文](https://medium.com/@ccrsh/introducing-prrrstack-pt-2-24704b5763b2)

### 系列文章：用Rust进行数据处理 Part 1

数据处理往往是Python的强项，但是该文作者会告诉你，Rust可以做的更好。

该文着重讲nalgebra，一个矩阵和向量的科学计算库。该系列文章之后还会介绍ndarray，相当于python中的numpy。

nalgebra允许开发者对矩阵（QR，SVD ......）进行多次分解，找到行列式和特征值，并进行大量的计算机图形操作（旋转，投影......等）

[原文](https://misoraclette.github.io/2018/08/04/data_manipulation.html)


### 使用Rust编写语言vm系列文章

已经更新到了 part 9

[原文](https://blog.subnetzero.io/)



### gfx-hal指南系列文章00： 小乌龟作画

gfx-hal是gfx-rs中包含的组件，gix的硬件抽象层

[原文](https://falseidolfactory.com/2018/08/16/gfx-hal-part-0-drawing-a-triangle.html)


### 「系列文章」Gfx-hal指南Part 2：顶点缓冲区（Vertex buffers）

[Read](https://falseidolfactory.com/2018/10/09/gfx-hal-part-2-vertex-buffers.html)

### 「研究项目」「系列文章」shifgrethor：Rust实现的垃圾收集库

Rust官方核心人员withoutboats开发了一个内存安全的垃圾收集库。它只是一个研究项目，并不能实际使用。

当然也可以用于学习目的，了解Rust的语言能力如何用于编码安全API中的复杂内存管理要求。

从长远来看，shifgrethor很可能会成为可用的高性能的垃圾回收器。当然，该项目不太可能成为Rust项目的常用功能。也就是说，请不要理解为「Rust要加GC了」。

shifgrethor的存在，只是为了要寻找一个实用的场景，用户可以使用GC来处理复杂的内存管理。比如涉及共享所有权的时候，可以使用动态的方式来管理内存。

shifgrethor是一个精准的跟踪GC

- 允许循环引用。不同于引用计数，这种GC不会导致内存泄漏。
- 精准的GC。它可以确切地知道哪些数据是活跃的，哪些不是。

Shifgrethor允许完全自由引用

- 可以解引用GC指针，可正常获得堆中的对象
- GC堆中的对象可以持有不在GC堆中对象的借用/引用，即使它们在栈上
- GC堆中的对象可以拥有栈中的对象。
- 可以讲GC指针从栈上移动到堆上。

GC是一种共享所有权，因此还需要内部可变性。

[shifgrethor](https://github.com/withoutboats/shifgrethor)

博文 [Read](https://boats.gitlab.io/blog/post/shifgrethor-i/)


### 「研究项目」「系列文章」Shifgrethor II ：跟踪垃圾回收器的注意事项

本篇主要是阐述了Shifgrethor 的工作方式：

将带有垃圾回收的Rust程序的内存分成了三个部分： 栈、托管堆（managed heap）和非托管堆（unmanaged heap）。

（让我想到了.net的CLR，看来上一篇的新闻内容我理解有点问题，不过没关系，看这篇纠正就可以了）

非托管堆： 是程序存储器的一部分，Rust程序员通常认为它就是堆，由内存分配器来分配内存，开发者可以自由调用，Rust里的`Box<T>`分配的就是非托管堆的内存。

托管堆： 提供了分配内存的API，但没有提供释放内存的API，由垃圾回收器来负责回收内存。这就是为什么它被成为「托管堆」

其实托管堆和非托管堆也不是完全独立的内存，其实可以在非托管堆的基础上实现托管堆。比如，可以实现一个库，将内存分配到非托管堆，然后该库实现一个自动的垃圾回收器，然后这个GC维护一个托管堆。这也正是Shifgrethor 要做的。

托管堆中的所有数据，实际上是存储在非托管堆的链表中，基本上是一堆Box。垃圾回收器依赖于这个链表，对数据进行标记，这就形成了一个保守的标记-清除的GC。

标记阶段有两个重要的部分：

- 生根（rooted）：非托管部分（包括非托管堆和栈）对托管堆的引用必须是rooted，这样GC才能知道从哪里去找actived 对象。有不同的生根策略，Shifgrethor 的比较独特。
- 发芽（Tracing）：从根的部分，跟踪和其关联的所有对象。也就是说，从根开始，标记和其关联的所有引用。可以将其看作是一种图形跟踪算法。

关于此GC的效率问题：

- 使用链表存在着一些问题，比如内存位置不连续，会导致内存缓存访问不佳且成本更高。
- 引入复制垃圾回收算法来解决这个问题。但是复制垃圾回收又为Rust引入了新的问题，将在后面的文章中介绍它。

下一篇将阐述，Shifgrethor如何rooted。

[ Read More ](https://boats.gitlab.io/blog/post/shifgrethor-ii/)

### 「研究项目」「系列文章」Shifgrethor III: Rooting

本文是Shifgrethor GC的第三篇，withoutboats讲述了该GC标记算法中如何标记根对象。

前两篇内容索引：

- [I](https://t.me/rust_daily_news/1437)
- [II](https://t.me/rust_daily_news/1476)

精确跟踪GC一般有两种rooting策略：

- 栈映射。编译器生成栈的元数据，来记录栈帧中GC指针的位置。GC按此元数据通过遍历栈来标识所有活动对象的根。
- 运行时收集。运行时维护所有活动对象的root集合。遵循此模式的大多数Rust实现都使用了侵入式双向链表。

栈映射通常被认为是最一流的办法，但是Rust遇到了一些问题。首先，栈映射需要语言自身支持，用库无法实现。其次，栈映射只能映射到栈，而不是堆。

所以shifgrethor最初的实现是利用了Pin API实现了一个侵入式双向链表。因为root指针不能被移动。本文主要描述了该设计遇到Rust借用检查器，产生的一些问题，以及他如何解决。将来也许可能增加新的语法来支持这个。后面会写文章专门讨论这个想法。

下一篇文章将讲述如何通过root跟踪GC堆的对象。

[ Read More ](https://boats.gitlab.io/blog/post/shifgrethor-iii/)


### 「研究项目」「系列文章」 Shifgrethor IV： 跟踪

关键字： [Shifgrethor, GC]

本文阐述了Shifgrethor如何跟踪对象，识别该对象是否存活。

定义Trace trait

跟踪算法原理：从根（root）开始，访问它引用的每个GC对象，并标记该对象为活跃对象，这样垃圾收集器就不会回收它。

该算法基于访问者模式。这是Rust社区普遍使用的模式，比如serde就是访问者模式。（插一句，《Rust编程之道》里也专门介绍了该模式）

```rust
pub unsafe trait Trace {
    fn mark(&self);
    // ...
}
```

所以，GC如果想跟踪某些对象，这些对象就必须实现Trace。实现Trace问题不大，但是证明GC对象是否被正确的追踪才是问题。

Proving rootedness

将这种保证跟踪是否正确的验证称为Proving rootedness。Shifgrethor的解决方案是引入新的类型GcStore。GcStore是一种没有实现Deref的gc指针。

```rust
#[derive(GC)]
struct Foo<'root> {
    #[gc] bar: GcStore<'root, Bar>,
}
```

上面代码会生成一个名为bar的方法，其函数签名为 `Gc<'root, Foo<'_>> -> Gc<'root, Bar> `，这是为了获得GC中某些内容的引用，必须始终证明是在该引用的生命周期内对其生根（rooted）

[Read More](https://boats.gitlab.io/blog/post/shifgrethor-iv/)


### 「系列文章」 From Rust to beyond前奏

这系列文章是讲Rust如何与其他语言交互

- WebAssembly
- ASM.js
- C
- PHP
- Nodejs

[原文](https://mnt.io/2018/08/21/from-rust-to-beyond-prelude/)


### 「系列文章」 From Rust to beyond 第二篇

用Rust编写webassembly库

[原文](https://mnt.io/2018/08/22/from-rust-to-beyond-the-webassembly-galaxy/)

### From Rust to beyond系列：asm.js

[原文](https://mnt.io/2018/08/28/from-rust-to-beyond-the-asm-js-galaxy/)


### From Rust to beyond系列： 与C交互

[原文](https://mnt.io/2018/09/11/from-rust-to-beyond-the-c-galaxy/)


### 「From Rust to beyond系列」 Rust与PHP交互

关键字:  [php, FFI, beyond]

[Read More](https://mnt.io/2018/10/29/from-rust-to-beyond-the-php-galaxy/)

### Programming Servo系列博文： 通用的worker事件循环

本文介绍了Servo中使用的通用worker事件循环组件 WorkerEventLoopMethods

[原文](https://medium.com/programming-servo/programming-servo-a-generic-worker-event-loop-400a6f113a60)

### Into Rust (1) - 为什么你应该使用 Rust 语言?

Rust 语言核心开发人员Niko Matsakis 的Rust教程系列，目前出了五期，这里是第一集熟肉，野喵Up主翻译。

[B站视频](https://www.bilibili.com/video/av30066131)


### 氧化 sourmash ：WebAssembly

这是 氧化 sourmash系列文章第二篇，

将代码库转换为Rust的过程在Rust社区中称为“氧化（Oxidizing）”

[原文](https://blog.luizirber.org/2018/08/27/sourmash-wasm/)


### Iridium是指用Rust编写的语言VM

感兴趣可以了解下，原文里包含了一系列如何使用Rust构建语言虚拟机的教程

[iridium-vm](https://blog.subnetzero.io/project/iridium-vm/)


### Rust源码分析：crossbeam之ms_queue(1)

crossbeam源码分析系列文章。

crossbeam是官方核心成语Aaron编写的并发库，提供了mpmc channel、scoped thread、并发数据结构、扩展了标准库的原子类型、以及其他的一些工具。

文章里介绍的是crossbeam库中Michael-Scott非阻塞队列(lock-free)算法的Rust实现，MS-queue算法主要依赖于CAS原子操作。

[原文](https://zhuanlan.zhihu.com/p/44104743)


### 系列文章 ： 探索Rust生命周期

[原文](https://exphp.github.io/2018/09/16/lockout-part-1.html)


### Rust 移动开发

该教程是在iOS上面使用Rust构建应用教程，这个系列应该还会包含安卓，可以关注一下

[原文](https://github.com/mtak-/rust-on-mobile/blob/master/examples/ios/example01.md)


### 「系列文章」为Eurobot创建机器人：第1部分

作者是为了参加某个机器人比赛，基于Raspberry PI 3，用Rust编写机器人固件

[原文](https://blog.florencepaul.com/creating-a-robot-for-eurobot-part-1-context)


### 系列文章：用Rust实现文字冒险游戏 1

[原文](https://www.cattlegrid.info/the-undergarden-text-adventure-rust-1-sections)


### 系列文章：用Rust实现文字冒险游戏 1 (jay)

[原文](https://www.cattlegrid.info/the-undergarden-text-adventure-rust-1-sections)
	
	### 并行化PNG压缩系列文章

出到了第五篇

[原文](https://brionv.com/log/2018/08/29/parallelizing-png-compression-part-1/)


### 「算法」探索航线谜题

#shipping_puzzle

在这系列文章里，作者探索了一道算法题：航线谜题（shipping puzzle）

第二篇是Rust实现方案。

航线谜题：

给定一组航段（leg）集合，每条航段分别对应于一周内的一天，包括起点和终点：

```
M PDX SEA （周一 PDX SEA）
T PDX SFO （周二 PDX SFO）
T SEA DEN （周二 SEA DEN）
W DEN PDX （周三 DEN PDX）
R PDX DEN （周四 PDX DEN）
F DEN JFK （周五 DEN JFK）
```

如何将以上航段划分为单个飞机的航线，受以下条件限制：

- 一条航段的目的地必须与下一条航段的起点相匹配
- 飞机必须持续航行（比如，一条航线不能包括：星期一 西雅图 -> 波特兰，然后是星期三 波特兰 -> 塔科马，此航线飞机在周二是闲置的。）

满足这些限制的简单方案是，将每条航段看作是一条单独的航线，但是需要多架飞机，但是一架飞机可以连续飞行的航段也可以看作是一条航线。现在问题是，如何找到最少的路线，也就是找到最少的飞机数。在此例中，我们最少需要两条航线。一种可能的解决方案是：让一架飞机飞行PDX、SEA、DEN、PDX、DEN、JFK航线，并且第二架飞机只在周二从PDX飞到SFO。

这里有一个[1w条航段的数据集](https://gist.github.com/lynaghk/0c75252b455e744ed3a8a0d09b493223)。可以开干了。

- [part 1](https://kevinlynagh.com/notes/shipping-puzzle/)
- [part 2](https://kevinlynagh.com/notes/shipping-puzzle/part-2/)



### 「系列文章」数独谜题生成器 pt.3: 使用WebAssembly

作者想用一个数独谜题生成器来检测WebAssembly的性能，他写了一系列文章，本文是第三篇，用Rust的wasm-bindgen工具来创建数独生成器的wasm模块。

[Read More](https://medium.com/@rossharrison/generating-sudoku-boards-pt-3-rust-for-webassembly-85bd7294c34a)


### 「系列文章」Pest vs Nom

#pest #nom #glsl

该作者正在编写glsl方面的库，他之前使用了nom，现在又引入了pest。然后通过写这一系列文章，来比较这两者在实践应用中的区别和定位。

Pest:

Pest在编译时使用一个文件，其中包含定义要解析的输入格式的PEG语法。PEG, 表示解析表达式语法，是一种形式语言，使你能够用规则描述自己的语言。这些规则是用一些属于语言理论的基本块编写的。如果你曾经听说过Stephen Kleene及其着名的Kleene star，你就会对PEG感到熟悉。

作者喜欢PEG的是，通过一组非常有限的结构，可以描述很多决定论语言。在GLSL450的情况下 - 这是glsl crate可以解析的语言 - 它是一种无上下文和确定性的语言。因此，整个语言可以根据（递归）PEG规则来定义。

Pest不是解析器，它应该是一种词法分析器。AST解析还需要自己来弄。也有人推荐用[pest-ast](https://github.com/pest-parser/ast)来处理AST。

Nom：

nom是一个解析器组合器。这意味着您可以通过组合小解析器来构建更大的解析器。关于nom的正确术语是它是一个无扫描器解析器：它不需要在解析之前生成令牌，并且更喜欢同时执行两者。 nom解析器通常使用像preceded！，delimited！，take_until！，tag！，value!和do_parse!等宏，允许匹配（lexing）切片的字节/字符，并使用你选择的类型将它们解析为实际值。

然而，Pest依赖于PEG文件，表示要标记的语言的正式语法。该词法分析器阶段发生并且必须能够在返回之前对整个输入进行标记。我不确定我什么时候说这个（但我很有说服力就是这种情况）：Pest不支持流输入，因为它需要吃特殊规则EOI（End Of Input ）， 或者在返回之前吃规则错误（使用先前的规则成功或向上传播错误）。但是，nom可以用来吃掉字节流。

[Part I](https://phaazon.net/blog/glsl-pest-part-1)
[Part II](https://phaazon.net/blog/glsl-pest-part-2)


### 「系列文章」数独谜题生成器 pt.3: 使用WebAssembly

#wasm #sudoku

作者想用一个数独谜题生成器来检测WebAssembly的性能，他写了一系列文章，本文是第三篇，用Rust的wasm-bindgen工具来创建数独生成器的wasm模块。

[Read More](https://medium.com/@rossharrison/generating-sudoku-boards-pt-3-rust-for-webassembly-85bd7294c34a)


### 「算法」探索航线谜题

在这系列文章里，作者探索了一道算法题：航线谜题（shipping puzzle）

第二篇是Rust实现方案。

航线谜题：

给定一组航段（leg）集合，每条航段分别对应于一周内的一天，包括起点和终点：

```
M PDX SEA （周一 PDX SEA）
T PDX SFO （周二 PDX SFO）
T SEA DEN （周二 SEA DEN）
W DEN PDX （周三 DEN PDX）
R PDX DEN （周四 PDX DEN）
F DEN JFK （周五 DEN JFK）
```

如何将以上航段划分为单个飞机的航线，受以下条件限制：

- 一条航段的目的地必须与下一条航段的起点相匹配
- 飞机必须持续航行（比如，一条航线不能包括：星期一 西雅图 -> 波特兰，然后是星期三 波特兰 -> 塔科马，此航线飞机在周二是闲置的。）

满足这些限制的简单方案是，将每条航段看作是一条单独的航线，但是需要多架飞机，但是一架飞机可以连续飞行的航段也可以看作是一条航线。现在问题是，如何找到最少的路线，也就是找到最少的飞机数。在此例中，我们最少需要两条航线。一种可能的解决方案是：让一架飞机飞行PDX、SEA、DEN、PDX、DEN、JFK航线，并且第二架飞机只在周二从PDX飞到SFO。

这里有一个[1w条航段的数据集](https://gist.github.com/lynaghk/0c75252b455e744ed3a8a0d09b493223)。可以开干了。

- [part 1](https://kevinlynagh.com/notes/shipping-puzzle/)
- [part 2](https://kevinlynagh.com/notes/shipping-puzzle/part-2/)

### Rust 移动端跨平台复杂图形渲染项目开发系列总结

#mobile #iOS #Android #gfx

作者是国内Rust社区的 @熊皮皮。 目录：

- Rust 2018开发环境配置与开发效率工具集
- C++与Rust变量声明的比较
- C++与Rust引用外部符号的比较
- C++与Rust数据类型对应关系
- C++与Rust操作裸指针的比较
- Rust日志输出实践总结

点击链接还有很多内容，还在不断更新。对移动端Rust应用和图形渲染感兴趣的朋友可以看看。另外，他们还在招聘。

[Read More](https://juejin.im/post/5bea5c2af265da613a538fb5)


### 「系列」Rust+GNOME Hackfest 记录 #4

#gnome #hackfest

[Read More](http://antoyo.ml/rust-gnome-hackfest-thessaloniki)


### 「系列博文」在浏览器中使用WASM Part 1

#wasm

本文介绍了如何使用Rust编译wasm，并在浏览器中使用它。同时也包括了wasm的工作机制，值得一看。

[Read More](https://ljcode.org/blog/wasm-part1/)


### 「系列」Rust Quiz 解读

[Quiz 1 ~ 10] ： [Read More](https://zhuanlan.zhihu.com/time-and-spirit-hut)

---

## series vedio


### 「演讲」使用Rust构建下一代网络基础设施

#conduit 

Buoyant的软件工程师Carl分享了在Conduit开发过程中利用Rust零成本抽象开发下一代网络基础平台。

[infoq 视频](https://www.infoq.com/presentations/rust-infrastructure)

### 「油管视频」devopsdays Edinburgh 2018大会：Rust与微服务

#youtube #rust #microservice

[youtube](https://www.youtube.com/watch?v=B4ccsfJ_IK8)

### 「Cpp 2018」在Clang中实现C++ Core Guidelines生命周期安全

#cpp #lifetime

对CPP熟悉的朋友可以关注下，也许通过该视频可以对Rust的生命周期有更深入的理解。

[youtube](https://www.youtube.com/watch?v=sjnp3P9x5jA)

### 油管视频：Rust是如何让高级类型系统接地气的

[How Rust Makes Advanced Type Systems Accessible to the Masses ](https://www.youtube.com/watch?v=P0L3gnO-3IM&feature=youtu.be)

### Rust NYC Meetup 活动视频

[原文](https://www.youtube.com/channel/UCU4-2XNjgtTp4LqE8LldEyw)

### Why Rust？

想在公司安利Rust的，可以看看这个视频。

[油管视频](https://www.youtube.com/watch?v=imtejBNbm0o&list=PLbWDhxwM_45mPVToqaIZNbZeIzFchsKKQ)

### 油管视频：Compiler Explorer的作者Godbolt的演讲：为什么C++还没死

在视频的结尾对比了Rust。在Reddit贴里有个评论有点意思：

> 说实话，在看着他谈论C ++的好处的时候，我忍不住想“是的，Rust也有这个特性，但是更好”：P

[讨论贴](https://www.reddit.com/r/rust/comments/8uhyj4/matt_godbolt_why_c_isnt_dead_he_talks_about_rust/)

### 油管视频：Learn+Try系列

- [Rust+ wasm](https://www.reddit.com/r/rust/comments/8r65jp/learntry_rust_in_the_browser_via_webassembly_rust/)
- [Rust ＋ nom](https://www.reddit.com/r/rust/comments/8r65cx/learntry_nom_rust_dc_may_10_2018/)

### 「油管」 这哥们要发布Hello Rust系列视频

可以关注下

[hello Rust](https://www.youtube.com/channel/UCZ_EWaQZCZuGGfnuqUoHujw)


### 「油管 Hello Rust系列」Go vs Rust： 并发与竞态条件

[原文](https://www.youtube.com/watch?v=B5xYBrxVSiE&feature=youtu.be)


### 「老视频收录」WebRender团队在某大学的宣讲系列视频 

#gfx-rs

主要讲WebRender中gfx-rs的应用。也包含一系列meetup视频列表，也可以看看。

[Read More](https://www.youtube.com/watch?v=SK5iEOc57wQ&list=PL85XCvVPmGQiSCQWoM29cP5lxPR-mvJd_&index=8&app=desktop)


### 「油管」学习Rust的内存、所有权和借用

[Learning Rust: Memory, Ownership and Borrowing](https://www.youtube.com/watch?v=8M0QfLUDaaA&feature=youtu.be)


###  Rust视频

18分钟Rust介绍视频（油管）：构建一个浏览器引擎。 [Intro to Rust-lang (Building a Browser Engine: Boxes and the Layout Tree)](https://www.youtube.com/watch?v=GuzZqrlc52s&feature=youtu.be)


### 油管视频：深度解析Trait

[Traits and You: A Deep Dive ](https://www.youtube.com/watch?list=PLgC1L0fKd7Ul71lD_cImGuMxsZ6J8fa06&time_continue=3&v=grU-4u0Okto)

### 油管视频：如何基于unsafe构建安全代码

[Building on an unsafe foundation](https://www.youtube.com/watch?v=rTo2u13lVcQ)

###  油管视频

[Rust Programming Techniques](https://www.youtube.com/watch?v=vqavdUGKeb4)
[RustBelt : Securing the Foundations of the Rust Programming Language](https://www.youtube.com/watch?v=Cy9NUVaiYUg&t=23s)

### Xi: 编辑器的未来20年

哇！ 野心很大。

[45分钟油管视频 Xi: an editor for the next 20 years](https://www.recurse.com/events/localhost-raph-levien)

![img](https://wx2.sinaimg.cn/mw690/71684decly1fnzvz77t1xj21k20wywq1.jpg)


### FOSDEM视频合集

[fosdem](https://video.fosdem.org/2018/H.2214/)

FOSDEM，自由及开源软件开发者欧洲会议(Free and Open source Software Developers' European Meeting，简称FOSDEM)是一个专为自由软件及开源软件开发者而设的周年会议，通常都一连两日，包括有讲座、导修工作室、摊位等。会议由比利时的布鲁塞尔自由大学及一班志愿人士一起筹备，被视为全欧洲、甚至全世界最优秀的自由软件及开源软件活动。

为什么今年80%都是讲Rust ？

### 油管视频 ：类型安全的高性能分布式actor系统（游戏相关）

构建分布式大型城市沙箱游戏的思考，来自于erlang的灵感，使用 rust实现Actor

[Type-safe & high-perf distributed actor systems with Rust](https://www.youtube.com/watch?v=qr9GTTST_Dk&feature=youtu.be)

[博客](http://cityboundsim.com/devblog/my-full-rustfest-talk-with-networking-live-demo)

[PPT](https://www.dropbox.com/s/z9ddkhz2pbidt8c/rustfest.pdf?dl=0)

[citybound 项目](https://github.com/citybound/citybound)

该视频里有点比较有意思的细节， 使用rust模仿erlang的actor模式，可以不需要supervision tree，完全用Rust的类型系统就可以保障安全，更轻量一些。
![gif](https://wx1.sinaimg.cn/mw690/71684decly1fo7pz0lr62g209902ugmp.gif)

### 「油管」Cologne Rust用户组线下活动视频分享

该视频讨论了CPU缓存和Rust中的数据结构，探索如何更好的编写代码以利用CPU缓存

[Rust Cologne, March 2018: Florian Zeitz - Caches and You](https://www.youtube.com/watch?v=GQBI-TcOTOk)

[更多主题](http://rust.cologne/2018/03/12/what-are-you-plotting.html)

### 油管视频：使用Rust构建异步ZooKeeper客户端

直播录屏，长达4小时。。

[原文](https://www.youtube.com/watch?v=mMuk8Rn9HBg)

### 水管视频：给初学者看的Rust并发

[twitch](https://www.twitch.tv/shakyshane)

### 视频：安全编程真的很慢吗？

该视频主要分享了如何在C代码中创造「安全区」，配合Rust来实现性能和安全双标准。

演讲者Pierre是ANSSI入侵检测研究实验室（LED）的负责人

[原文](https://passthesalt.ubicast.tv/videos/secure-programming-is-slow-really/)

### 「推荐仔细品味」「油管」从C到Rust的一些模式

该视频是GUADEC 2018（可能是什么大会）上面第一个主题分享，主要内容是介绍了如何将遗留的C语言的系统用Rust进行重构。视频中给出了一些模式和技巧，比如如何给C语言暴露Rust迭代器等，推荐仔细看看。

[原文](https://www.reddit.com/r/rust/comments/94rp03/guadec_2018_federico_mena_quintero_patterns_of/)

### 视频： 函数式Rust

讨论在Rust中如何编写函数式代码

[函数式Rust](https://www.infoq.com/presentations/functional-rust)

### RustConf 2018视频已上传油管

[RustConf+2018 @ YouTube](https://www.youtube.com/results?search_query=RustConf+2018)

### 「长文预警」Solana 、Zcash 和Parity 三家会面讨论为什么Rust适合区块链开发

- [Solana](https://github.com/solana-labs)是一种高性能区块链
- [Zcash](https://github.com/zcash/)是一种加密货币
- [Parity](https://github.com/paritytech/)是一个核心的区块链基础公司，以太坊相关

文章里包含了视频，以及视频的文字实录。

有空我把它翻译出来。

[原文](https://medium.com/solana-labs/solana-at-portland-dev-meetup-72e4dc7ad32c)

### 「油管」 某线下meetup 视频 ： Python和Rust在生产环境的集成

[视频](https://www.youtube.com/watch?v=IJBmqPzE6qY)

### 「视频」无恐惧多媒体编程

GStreamer是Linux世界中多媒体编程的首选框架，尤其用于嵌入式，但是传统都是C/C++来编写GStreamer的应用程序和插件。不幸的是，这种效率是以安全为代价的。即便是最熟练的C/C++开发人员也会在内存管理方面犯错，结果可能是灾难性的。线程安全是多媒体解决方案的核心，但是用C/C++极难实现。

在本次视频演讲中，Zeeshan介绍了使用GStreamer的Rust绑定如何安全、简单地编写多媒体应用程序。

[原文](https://media.ccc.de/v/ASG2018-172-fearless_multimedia_programming)

### 「油管」Andrea Pessino 展示Rust实现的三次参数曲线(Cubic Curves)

Cubic Curves是贝赛尔曲线(Bézier Curve)的基础，一个三位空间曲线通过转换投影到2D平面的曲线。

Andrea Pessino是曾开发 《战神：奥林匹斯之链》 和《 战神：斯巴达之魂》 的业界大厂 Ready at Dawn Studios 的CTO。

[视频](https://www.youtube.com/watch?v=rXjkXqI2Yyc)

### 「视频」Bay Rust Meetup上排名前100的crate介绍

该视频介绍了Rust生态系统中前100个crate

文字总结：http://thume.ca/crates/

[Read](https://watch.cloudflarestream.com/6cc794b568e4b4b19153355e247ff6dd)

### 「视频」Bay Rust Meetup上排名前100的crate介绍

该视频介绍了Rust生态系统中前100个crate

文字总结：http://thume.ca/crates/

[Read](https://watch.cloudflarestream.com/6cc794b568e4b4b19153355e247ff6dd)

### 「Slides」禅与说服贵公司使用Rust的艺术

关键字: [convinced, use rust]

Rust核心团队成员Ashley Williams（@ag_bubs），同时也是crates.io、Rust社区的团队领导，WebAssembly工作组的成员分享了这篇主题。

「视频地址：」[How I Convinced the World's Largest Package Manager to Use Rust, and So Can You!](https://www.youtube.com/watch?v=GCsxYAxw3JQ)

[PPT](https://ashleygwilliams.github.io/gotober-2018/#1)

### 「博文」利用Rust所有权语义来构造有约束的API

#api_design

该文作者在2017年的Rust Fest大会做了分享，直到昨天，他才把演讲内容更新成了文稿。

[演讲视频](https://www.youtube.com/watch?v=3Q2hQfYW-XM&index=9&list=PL85XCvVPmGQj9mqbJizw-zi-EhcpS5jTP)

（ 我在《Rust编程之道》一书的设计模式 - RAII模式 里也借鉴了他的这次演讲内容 ）

[Read More](https://blog.systems.ethz.ch/blog/2018/a-hammer-you-can-only-hold-by-the-handle.html)

### 「录播视频」11-07晚上杭州秘猿Rust开发分享会

秘猿计划每个月的Dev Meetup第一场都会开设Rust专题

B站视频前面几分钟无声音，后面有了

[ B站 ](https://www.bilibili.com/video/av35546990/)

[ 油管视频声音比较完整 ](https://www.youtube.com/watch?reload=9&v=s7gFNTb3rWU&feature=youtu.be)



---

## practice

### 「Rust练手小项目」

- 统计git commit中的「咒骂」词语: [git-anger-management](https://github.com/sondr3/git-anger-management)
- Rust语法糖集合，该库提供了作者编写的一些语法扩展，方便使用的宏: [sugar-rs](https://github.com/harryfei/sugar-rs)

### 「练手小项目」如何计算Pi

[五种计算Pi的方法](https://www.wikihow.com/Calculate-Pi)

[Read More](https://www.reddit.com/r/rust/comments/9q63dk/trying_to_calculate_pi/)

### 「Rust练手小项目」

- 统计git commit中的「咒骂」词语: [git-anger-management](https://github.com/sondr3/git-anger-management)
- Rust语法糖集合，该库提供了作者编写的一些语法扩展，方便使用的宏: [sugar-rs](https://github.com/harryfei/sugar-rs)


---

## book

### 新书预发布 Rust Programming Language, The (Manga Guide) 

[地址](https://www.amazon.co.uk/Rust-Programming-Language-Manga-Guide/dp/1593278284/ref=tmm_pap_swatch_0?_encoding=UTF8&qid=1514591488&sr=8-2)

![img](https://wx3.sinaimg.cn/mw690/71684decly1fn0w2e917vj215s0kq0xj.jpg)

<Jay> 
{
https://www.armstrong-publications.com/

Currently, we are looking for the authors in these areas:

SaltStack
InfluxDB
Capistrano
Mustache
Docker
Actor
Backbone Marionette
Jenkins
ELM
Rust
}

### oreilly免费书下载：Why Rust

[why Rust](http://www.oreilly.com/programming/free/why-rust.csp?intcmp=il-prog-free-product-lgen_why_rust)

<Jay> Why. 

### 免费书籍推荐：CODE ARTISTRY BOOK (jay)

副标题：A Practical Guide To Rust 卷1

[官网](https://thedarkula.gitlab.io/code-artistry/book/)

[PDF](https://thedarkula.gitlab.io/code-artistry/book/VolumeI.pdf)

<Jay> It is to be read at 2020.

###  Rust新书发布：Step Ahead With Rust  

[原文](https://users.rust-lang.org/t/new-book-release-step-ahead-with-rust/16842)

据介绍，这是一本面向中高级Rust开发人员的书籍，内容包括了Cargo、Cell、和unsafe
 Rust等。
 
<Jay> $33.

### 又一本学习Rust的书出炉

[step ahead Rust](https://www.amazon.com/Step-Ahead-Rust-Jonathan-Creekmore/dp/0999361805/)

<Jay> ...

### 嗯？Rust wasm之书？

[rust wasm](https://github.com/rust-lang-nursery/rust-wasm/issues/41)

<Jay> It move to rustwasm team. [rustwasm](https://github.com/rustwasm/team)


### 通过Rust来探索微控制器的世界

Rust团队嵌入式小组的leader开放了一本书，让你了解嵌入式微控制器的世界。

- [discovery book](https://japaric.github.io/discovery/)
- [Discovery: Discover the world of microcontrollers through Rust!](https://www.reddit.com/r/rust/comments/80doqg/discovery_discover_the_world_of_microcontrollers/)

<Jay> It could be read the blog. [Embedded in Rust](https://blog.japaric.io/)

### 官方正在筹备嵌入式开发之书

[The Embedded Rust Book](https://github.com/rust-lang-nursery/embedded-wg/issues/56)

<Jay> [The Embedded Rust Book](https://rust-embedded.github.io/book/)

### 又一本Rust的新书

可惜是葡萄牙语的

[sumario-rust-funcional-concorrente](https://www.casadocodigo.com.br/pages/sumario-rust-funcional-concorrente)

<Jay> ...

### 新书：Rust网络编程

[亚马逊地址](https://www.amazon.com/Network-Programming-Rust-memory-safety-concurrency/dp/1788624890)

<Jay> It to be read at 2020.

### Rust新书：Rust High Performance

高性能Rust

[Rust High Performance](https://www.packtpub.com/application-development/rust-high-performance)

[源码](https://github.com/PacktPublishing/Rust-High-Performance)

<Jay> It to be read at 2020.

### 社区新书：A Gentle Introduction to Rust

[A Gentle Introduction to Rust](http://stevedonovan.github.io/rust-gentle-intro/)

<Jay> It is could be skimming and trying.

### Rust实践：Ray Tracing in One Weekend 电子书

这是一本最正经介绍RayTracing（光线追踪）入门知识的书，该库作者使用Rust实现了一遍。

[raytracing-rs](https://github.com/AlexEne/raytracing-rs)

<Jay> Why is 'Raytracing in one weekend'?

### 「英文」Rust社区又一本新书发布

侧重于并发相关内容

[原文](https://blog.troutwine.us/2018/06/07/hands-on-concurrency-with-rust/)

<Jay> [async-book](https://rust-lang.github.io/async-book/)

### wasm-bindgen之书

[原文](https://rustwasm.github.io/wasm-bindgen/basic-usage.html)

<Jay> [Rust and WebAssembly](https://rustwasm.github.io/docs/book/)

### 新书：用Rust编写WebAssembly

beta版可预定。

[programming-webassembly-with-rust](https://pragprog.com/book/khrust/programming-webassembly-with-rust)

### 书籍预告：  Programming WebAssembly with Rust

该文作者准备和https://pragprog.com/合作，正在写一本书《Programming WebAssembly with Rust》。

目前进度已完成 2／3，可以关注下

[原文](https://medium.com/@KevinHoffman/programming-webassembly-with-rust-the-book-7c4a890fcf97)

<Jay> $29.45

### 免费书籍推荐：CODE ARTISTRY BOOK

副标题：A Practical Guide To Rust 卷1

[官网](https://thedarkula.gitlab.io/code-artistry/book/)

[PDF](https://thedarkula.gitlab.io/code-artistry/book/VolumeI.pdf)

### 新书：用Rust编写WebAssembly

#wasm

beta版可预定。

[programming-webassembly-with-rust](https://pragprog.com/book/khrust/programming-webassembly-with-rust)

<Jay> To read. [source code](https://pragprog.com/titles/khrust/source_code)

### Rust免费书：Rust基础指南 

#ebook

[Read More](https://www.reddit.com/r/rust/comments/a17dqa/ebook_rust_programming_language_tutorial_basics/)

<Jay> try.

### 解析工具选择之书 (jay)

#book #nom #pest

有人写了一本书，罗列了现在的解析工具，比如nom、combine、pest等，提供了一些文档和示例，帮助你选择适合使用场景的解析工具。目测还在完善中。

[Read More](https://freemasen.github.io/parsers_presentation/)

<Jay> It is could be skimming and trying. (https://github.com/FreeMasen/parsers_presentation) [ress](https://github.com/FreeMasen/ress) [ressa](https://github.com/FreeMasen/ressa)

---

## WebAssembly

### 使用WebAssembly 实现的 `A *寻路` demo

[wasm-astar](https://github.com/jakedeichert/wasm-astar)

![img](https://github.com/jakedeichert/wasm-astar/raw/master/dist/demo.gif)

###  另一个Rust + WebAssembly的项目

[Hassel Wasm DBG](https://jdisanti.github.io/hassel_wasm_dbg/)

### Mozilla长文：用wasm重构source map

Source map是用来转换js代码的文件，比如压缩js文件、合并js库等功能都可以用得到。

[oxidizing source maps with rust and webassembly](https://hacks.mozilla.org/2018/01/oxidizing-source-maps-with-rust-and-webassembly/)

此次用可编译为wasm的Rust代码替换了source map js库中解析器性能最敏感的部分，速度提升了5.89倍。这篇文章总结了他的经验，希望可以借此激励他人使用rust和wasm替换掉js中需要性能的部分。

### 另一篇Wasm和Javascript的性能分析文

[floyd steinberg dithering](https://www.polaris64.net/blog/programming/2018/rust-webassembly-javascript-floyd-steinberg-dithering-performance)

### Turtle：使用Rust+wasm制作动画   

[turtle](http://turtle.rs/)

[turtle intro](https://varblog.org/blog/2018/01/08/rust-and-webassembly-with-turtle/)

### 在线Webassembly IDE，支持Rust和C

[wasm studio](https://webassembly.studio/)

### Porting Rust to WebAssembly

从Rust迁移到WASM的经验之谈

[Porting Rust to WebAssembly](https://udoprog.github.io/rust/2018-02-19/porting-rust-to-wasm.html)

### 使WebAssembly更好地适用于Rust甚至所有语言

 Lin Clark 被编程耽误的漫画家又出手了。

[Making WebAssembly better for Rust & for all languages](https://hacks.mozilla.org/2018/03/making-webassembly-better-for-rust-for-all-languages/)

### Combining  Three.js, Rust, and WebAssembly

[Parc3l: Combining Three.js, Rust, and WebAssembly!](https://medium.com/@cwervo/parc3l-combining-three-js-rust-and-webassembly-c1e643ef7681)

### cargo web帮助快速构建Web客户端

-  cargo web build - 支持:
    - asm.js using Emscripten (when you pass --target=asmjs-unknown-emscripten; default)
    - WebAssembly using Emscripten (when you pass --target=wasm32-unknown-emscripten)
    - WebAssembly using Rust's native WebAssembly backend (when you pass --target=wasm32-unknown-unknown, requires Rust nightly)

[cargo web](https://github.com/koute/cargo-web)

### C++ WebAssembly编译工具

发现支持mir2wasm 就是从 Rust MIR编译到wasm

[binaryen](https://github.com/WebAssembly/binaryen)

### WebAssembly在线IDE

[  WebAssembly.Studio 介绍]( https://hacks.mozilla.org/2018/04/sneak-peek-at-webassembly-studio/)

### 介绍rust和wasm如何通信

[原文](https://medium.com/@KevinHoffman/javascript-interop-with-webassembly-2c69a3db19e9)

### （打算）实现在Ring 0中运行的WebAssembly  “usermode（用户模式）”的微内核

[nebulet ](https://github.com/nebulet/nebulet)

### Rust and WebAssembly本周消息

[Rust and WebAssembly 001](https://rustwasm.github.io/2018/04/21/this-week-in-rust-wasm-001.html)

### Rust和WebAssembly每周摘要第4期

新的crate、工具或项目：

- rust+wasm写的游戏: http://www.matthewmichelotti.com/games/project_ice_puzzle/
- wasmbooth，rust+wasm实现的视频捕捉，https://mtharrison.github.io/wasmbooth/
- wasmparse-{core,bridge,web} ，基于浏览器的交互式Wasm反汇编程序（正在进行中）。它的目标是向人们传授webassembly格式，webassembly代码以及堆栈机的工作原理。
- wasm-pack/ wasm_alloc/ Twiggy均已发布了新版本
- jpeg-decoder库现在已支持wasm和asm.js

另外还有很多wasm相关文章介绍

[原文](https://rustwasm.github.io/2018/07/10/this-week-in-rust-wasm-004.html)

### Rust and WebAssembly 周报 005

基本上里面的内容「每日新闻」近日都发布过了

[原文](https://rustwasm.github.io/2018/08/01/this-week-in-rust-wasm-005.html)

### QT WASM技术预览版发布

可以在浏览器运行QT了

[原文](http://blog.qt.io/blog/2018/04/23/beta-qt-webassembly-technology-preview/)

### WASM 在线IDE

[wasm IDE](https://webassembly.studio/)

### 使用Rust的LLVM来生成WASM

[原文](https://medium.com/@jayphelps/using-llvm-from-rust-to-generate-webassembly-93e8c193fdb4)

### 利用rust和wasm加速Azure  serverless服务

[原文](https://blog.x5ff.xyz/blog/azure-functions-wasm-rust/)

### GSoC （Google Summer Summer of Code ）2018 Week 0 ：

台湾交大一哥们想给Webpack附上WASM魔法提升性能

他在GSoC上的项目，是打算重写Webpack的核心（用Rust）可以直接编译到WASM，从而提升性能。

[gsoc 2018](https://medium.com/webpack/webpack-with-webassembly-gsoc-2018-week-0-f77f9841b01)

### This Week in Rust and WebAssembly 002

四个新的工具：

- Cervus
- gutenberg-parser-rs
- wasm-to-rust
- wasmboy-rs

还有很多新库发布新版本，以及一些PR动态，比如Futures 0.2 support stdweb

[详情](https://rustwasm.github.io/2018/05/14/this-week-in-rust-wasm-002.html)


### 可以跑在webassembly studiios 的贪食蛇游戏

[原文](https://www.reddit.com/r/rust/comments/8ko849/webassembly_studios_snake_game/)


### 基于Cervus实现cat命令

Cervus是国人（QQ群友）搞的构建于Linux之上的WASM微内核。作者还搞了一个GitHub组织CommonWA， 看来是侧重于探索wasm的通用领域。 https://github.com/CommonWA

[原文](https://www.reddit.com/r/rust/comments/8mhddt/cat1_implemented_on_webassembly_cervus/)

### 整合Rust+wasm+vue组件

[原文](https://busy.org/@drsensor/mix-rust-code-webassembly-with-vue-component-basic)

### parcel 前端打包工具新版本发布，宣布支持wasm+Rust

[parcel v 1.5.0](https://medium.com/@devongovett/parcel-v1-5-0-released-source-maps-webassembly-rust-and-more-3a6385e43b95)

### JSConfEU大会上Rust+Wasm吸引眼球

![img](https://wx4.sinaimg.cn/mw690/71684decly1frxuidju7tg20e10etu0y.gif)

顺带附上一个教程（如果你有机会玩Arch）：

JSConf EU大会上有一个大型设备Arch（应该是Mozilla的），是由3w个led彩色灯组成的画布，可以创建动画。

作者Lin Clark写这个教程，是希望能参加大会的人可以有机会用rust+wasm写一个模块跑在Arch上面，因为以往都是js模块，这次来个不一样的。

[教程](https://hacks.mozilla.org/2018/06/babys-first-rustwebassembly-module-say-hi-to-jsconf-eu/)


### 官方：我们对Rust和WebAssembly的愿景

工作组愿景： 如外科手术般插入由Rust编译的wasm来加速JavaScript性能敏感的代码，而不需要扔掉或重写现有的代码库，也不需要更改现有的开发流程，做到无缝集成。

几点原因：

- 为什么关注性能敏感的代码？ 因为js的优化并没有那么简单，而使用Rust你根本不需要成为js优化专家，不需要熟悉JIT内部实现，不需要魔法也能加速。
- 方便集成。直接编译为.wasm，使得现有的js代码库可以增量式部分采用Rust。而且还可以保持你现有代码库，不需要重写。
- 不需要更改你现有开发流程。对于js开发者，可以将.wasm发布到npm，然后在package.json中依赖它。可以导入为ECMAScript模块，遵循CommonJS风格的require，或者作为新的对象添加到JS全局。而对于Rust开发者来说，可以将.wasm发布到npm，甚至都不需要安装nmp、nodejs等js环境。wasm-pack会编译，优化并生成js绑定，然后发布到npm中。

当前状态和工具集：

- 正在写的书：The Rust and WebAssembly Book
- wasm-bindgen，帮助Rust和js通信。甚至通过它可以在js和rust之间发送string和struct这样的类型，而不仅仅是wasm标准里的整数和浮点数。
- wasm-pack，一站式构建、发布Rust编译的wasm。
- Twiggy ，检查.wasm代码尺寸的工具
- wee_alloc，为wasm设计的小型内存分配器
- wasm-snip，可以用一条unreachable指令强制替换函数的主体。用于在运行时永远不会使用的函数的情况。配合wasm-gc。
- console_error_panic_hook，将Rust内部编译错误在浏览器端显式，方便调试

当然，未来还需要更多的新伙伴加入Wasm工作组，共谋大业。

[原文](https://rustwasm.github.io/2018/06/25/vision-for-rust-and-wasm.html)

### 官方： 我们对wasm-bindgen的愿景

该篇文章官方探讨了wasm-bindgen 的细节，以及对未来的设想。

wasm-bindgen的核心是促进javascript和Rust之间使用wasm进行通信。它允许开发者直接使用Rust的结构体、javascript的类、字符串等类型，而不仅仅是wasm支持的整数或浮点数。开发者只需要专注于他的业务。

另外，wasm-bindgen还将支持wasm即将发布的Host Bindings提议，该提议的目标如下：

-  人体工程学 - 允许WebAssembly模块创建，传递，调用和操作JavaScript + DOM对象。
- 速度 - 允许对JS / DOM或其​​他host调用进行良好的优化。
- 平台一致性 - 允许WebIDL用于标注Wasm导入/导出（通过工具）。
- 增量机制 - 提供方便填充的策略。

这有望解锁更快的dom访问，因为dom api可以在编译为wasm时进行验证，就不需要每次在调用时动态检查了。

wasm-bindgen致力于为javascript生态和Rust crate生态系统建立共享的基础。

- 共享原生的外部导入。
- 共享的ECMAScript全局API，每个javascript环境中可用的全局API都可以通过wasm_bindgen :: js模块获取。当然，这里面有一些体力活，需要人手来共同完成，官方也开了issues来忽悠大家一起完成，并且手把手教了方法，想参与贡献的可以去wasm_bindgen的issues列表中查看。
-  所有的Web API类型、函数和方法都是由WebIDL来指定，目前正在为wasm-bindgen开发一个新的WebIDL前端。新的前端意味着，wasm-bindgen会解析WebIDL并将其转换为wasm-bindgen的AST，再进行后面的过程。

[原文](https://rustwasm.github.io/2018/07/02/vision-for-wasm-bindgen.html)

### WebAssembly  不仅仅是Web

虽然WebAssembly名字里包含了Web，但实际上它并不仅仅局限于Web。

很多程序员知道WebAssembly是运行于浏览器中执行非JS代码的一种技术。这是事实，但实际上还有更多的内容。

为了将WebAssembly嵌入到不同的环境中，其规范是被拆分到独立的文档中并区分了层级：

- 核心层。定义WebAssembly模块及其指令集的语义。
- API层。定义应用程序接口。目前指定了两个API：JavaScript API、Web API。

由此看出，WebAssembly其本身是独立于Web的，Web只是其应用的特定环境。事实上，WebAssembly也被应用于很多除了Web之外的领域：

-  桌面图形化程序
-  区块链智能合约，比如Parity的以太坊VM
-  编写操作系统微内核，比如Nebulet

等等，请发挥你的想象力。

[原文](http://words.steveklabnik.com/webassembly-is-more-than-just-the-web)

### Arch： 使用rust和webassembly为3w个Led彩灯制作动画

Lin Clark在jsconf上面的演讲视频

[原文](https://hacks.mozilla.org/2018/07/the-arch-using-rust-webassembly-to-animate-30k-colored-led-lights/)

### WebAssembly是Java Applets和Flash的回归吗？

作者（steveklabnik）针对这种言论给出了反击理由

[原文](https://words.steveklabnik.com/is-webassembly-the-return-of-java-applets-flash)

### Rust+WebAssembly构建同构的Web App

实现了一个虚拟dom，可以根据服务端的HTML字符串渲染到浏览器的dom，完全同构，纯Rust+Wasm

[percy](https://github.com/chinedufn/percy)


### 在Rust中编写前端WASM框架的教训和经验

该作者用Rust和WASM实现了一个前端开发框架smithy，并且用smithy实现了一个TODO List demo

[原文](https://medium.com/@robert.balicki_2494/writing-a-front-end-webassembly-framework-in-rust-lessons-learned-7cc48ed27d96)

[smithy](https://github.com/rbalicki2/smithy)

[Demo](https://todolist.robertbalicki.com/)

### Rust 和Wasm 本周报告第6期

简要：

-   正在为wasm添加SIMD 128位矢量类型的支持
-   让Firefox的debbuger工具可以使用DWARF调试信息对Rust+Wasm的内联栈帧进行调试，WebAssembly官方成立了调试小组
-  wasm-bindgen 0.2.16发布
-  首次发布wasm-bindgen-futures，支持在Rust Futures和JavaScript Promises之间无缝切换。
-  在wasm book中增加了两章：「你应该知道的工具」以及「你应该知道的crate」
-  rustwasm组收到了新的RFC： 通过wasm-bindgen实现Rust的trait和Javascript的类继承的无缝切换。此功能在stdweb中已经被实现。

[原文](https://rustwasm.github.io/2018/08/14/this-week-in-rust-wasm-006.html)

![2018-08-09 19.06.51.gif](https://cdn.steemitimages.com/DQmWJqDxJuKfGeTZ1SS5QJoD9EcoqEXJptbQQwnaXjJurEE/2018-08-09%2019.06.51.gif)
![img](https://wx4.sinaimg.cn/mw690/71684decly1fua5ta1l4jg21kw0wbb2d.gif)

### Rust和WebAssembly 本周报告第7期

新工具和项目：

-  用Rust实现的Jczsolve Sudoku Solver（数独求解器），并编译到了wasm，[在线示例](https://emerentius.github.io/sudoku_web/)
- Wasabi，WebAssembly的动态分析框架
- greenwasm， Rust实现的wasm规范（上面已介绍），即wasm引擎

另外还需要人手去做贡献，具体问题查看下面链接

[原文](https://rustwasm.github.io/2018/09/04/this-week-in-rust-wasm-007.html)

### Rust和WebAssembly本周报告 008

简要：

- wasm-pack大版本发布
- web-sys crate发布
-  《Programming WebAssembly with Rust 》Kevin Hoffman正在为Pragmatic Programmers图书出版商撰写一本关于Rust和Wasm的书
-  [SFHTML5聚会的视频录制和幻灯片](http://fitzgeraldnick.com/2018/10/01/sfhtml5-rust-and-wasm-talk.html)，都是关于wasm的，[幻灯片地址](https://rustwasm.github.io/sfhtml5-rust-and-wasm/#1)
- rustfmt编译为wasm，用于在浏览器中格式化代码
- Olin，服务端wasm平台
-  P64Lang解析器和解释器作为wasm模块运行
- [wasm-bindgen如何促进Rust和JavaScript之间的互操作](https://blog.ryanlevick.com/posts/wasm-bindgen-interop/)

详细内容请看： [原文](https://rustwasm.github.io/2018/10/01/this-week-in-rust-wasm-008.html)

### 「Rust WASM小组」多线程Rust和WASM

本文介绍了WebAssembly线程提案，简要：

- WebAssembly的线程提案不是准备好一个线程库让你调用，而是指定了基本的线程构建块。
-  线程提案中首先添加了原子指令。同时提供了i32.atomic.wait和atomic.wake指令来阻塞和唤醒线程，这就形成了一种底层的原语，比如可以用它来实现互斥锁。
- 通过web worker实现并行。但是目前web worker共享资源的能力比较弱，只能通过发送消息。但是在Rust看来，js里的对象很少有可以直接Send的对象，在线程间发送对象总是需要clone。现在通过在线程间传递WebAssembly.Module，则可以极大降低clone的成本。
- 利用SharedArrayBuffer 共享内存。
-  一次性初始化内存。当前的wasm自动初始化内存在多线程情况下会导致不安全。所以必须使用一次批量申请内存的策略。多线程下，只能有一个线程负责初始化。将自动改为手动，模块必须通过memory.init指令手动初始化内存。

以上是线程提案中的重点。

线程和wasm-bindgen：

-   wasm-bindgen工具由两部分组成：派生宏#[wasm_bindgen]和cli。 wasm-bindgen cli工具现在使用parity-wasm库来解析Wasm，该库极大地增强了cli的功能，并摆脱了LLVM的束缚，可以访问Wasm的完整功能集。
-  wasm-bindgen可以在线程本地存储中注入全局变量，这个是LLVM/LLD当前无法做到的，但是wasm-bindgen做到了。 可以方便地将此变量添加到wasm模块中。
-  通过定义ID为0的全局线程变量，来判断是不是主线程。如果是0则是主线程，则调用wasm的memory.init来批量分配内存，解决多线程下wasm自动内存分配带来的不安全问题。
-  管理 WebAssembly.Memory。在多线程情况下，希望所有的模块都使用相同的内存实例。目前wasm-bindgen给出了一个临时方案。使用—no-modules参数，将模块的路径实例化，在创建内存的时候再进行实例化，然后将其实例化的模块分发给每个worker。 等线程提案稳定之后，会完善更多细节。
-  演示实例：并行化光线跟踪 [raytrace-parallel](https://github.com/rustwasm/wasm-bindgen/tree/master/examples/raytrace-parallel)

虽然wasm-bindgen现在已经可以制作演示实例，但实际上离真正可用还有一段距离，还有很多问题需要解决。

[ WebAssembly线程提案 ](https://github.com/WebAssembly/threads/blob/master/proposals/threads/Overview.md#atomic-memory-accesses)

[ Read More ](https://rustwasm.github.io/2018/10/24/multithreading-rust-and-wasm.html)

### WebAssembly和动态内存

本文介绍了C/C++/Rust下如何在面向WebAssembly体系下进行动态内存分配，并分别比较了它们的工具链。

结论是：Rust的编译器和动态内存分配器wee_alloc的组合是明显的赢家，其生成的WebAssmebly代码非常精简，可以用在任何WebAssembly环境中。主要是因为Rust工具链没有其他的依赖。像Clang这种工具链依赖于emscripten，就导致无法在通用的WebAssembly环境中使用。

[原文](https://frehberg.wordpress.com/webassembly-and-dynamic-memory/)

### WebAssembly： How and Why

WebAssembly对JavaScript和Web开发的未来意味着什么？

为什么需要WebAssembly？

-  将许多其他应用程序能做的事带到浏览器上，比如运行大型游戏、渲染等需要大量计算的事情
-  Web才是未来，真正的通用平台
-  WebAssembly提供了速度、可移植性和灵活性。 wasm文件大小比js更小，速度更快，更可靠的性能保证
-  WebAssembly提供了可移植性。不仅仅是Web可用，其他平台也可用，包括iOS和Android、区块链等。
-  WebAssembly提供了巨大的灵活性。JS将不再是浏览器支持的唯一语言，在遇到瓶颈的时候，开发者可以选择任意喜欢的其他语言（包括js本身）来优化现有js系统的性能，并且是无缝对接。目前C、C++、Rust、Kotlin和.NET均先后增加支持

WebAssembly如何工作？

-  需要一个将代码编译为WASM的工具。C/C++通过LLVM和Emscripten，而Rust编译器可以直接编译wasm。
-  将编译出来的wasm通过js加载，可以和js无缝互通

未来？

-  正在开发新的特性
-  比如支持dom、线程和垃圾回收
-  支持调试工具
-  虽然js无法直接编译为wasm，但是有工具可以将js转换为wasm的文本格式，然后再转为wasm

[原文](https://blog.logrocket.com/webassembly-how-and-why-559b7f96cd71)

### Rust和WASM实现的交互式文本游戏

最流行的一个是Z-Machine，该网站就是Z-Machine的Rust和WASM实现

[原文](https://sterlingdemille.com/encrusted/)
[源码](https://github.com/demille/encrusted)


### 光线跟踪： WebAssembly vs Javascript

作者用用3D光线跟踪的案例来学习WebAssembly，想看看它在计算密集型应用中的表现。

结果很吃惊：

- WebAssembly: 22.0fps
- JavaScript: 2.5fps

WebAssembly性能是JS的9倍。

作者使用Rust工具链： wasm-bindgen和wasm-pack，在Firefox Quantum 61.0.2浏览器进行测试。

[原文](http://matt-harrison.com/raytracing-webassembly-vs-javascript/)

[源码 ](https://github.com/mtharrison/wasm-raytracer)


### Olin：服务器端WebAssembly平台 -

通过Rust编译为wasm32-unknown-unknown来提供HTTP服务

[源码](https://github.com/Xe/olin/tree/master/cwa/olin)

[heroku demo](https://olin-http-example.herokuapp.com/)


### Smithy进度更新：我如何将WebAssembly 打包尺寸减少90％

Smithy，一个用Rust编写的Web开发框架，可以编译为WebAssembly，它的目标是让你使用惯用的Rust来编写前端代码。

开始准备alpha版本了。新版本使用了wasm-bindgen提供的js-sys和web-sys

- [smithy](https://github.com/rbalicki2/smithy)
- [jsx_compiler](https://github.com/rbalicki2/jsx_compiler)
- [wasm_website_frontend](https://github.com/rbalicki2/wasm_website_frontend)

[原文](https://medium.com/@robert.balicki_2494/smithy-progress-update-how-i-decreased-webassembly-bundle-size-by-90-e7fe194b2f58)


### wasm-pack 大版本发布  

wasm-pack 0.5版本发布，这是迄今为止发布的最大的一个版本。截止今天，终于有了一套Rust和WebAssembly梦寐以求的工作流程。

简要：

-  拥有了[独立网站](https://rustwasm.github.io/wasm-pack/)，包含了在线的文档
-  支持js模块
-  0.5版本已经将wasm-pack打造成一个集成构建工具，引入了新的命令`wasm-pack init` 、`wasm-pack test`和`wasm-pack publish`

还有其他很多新的功能，详细请看[Changelog ](https://github.com/rustwasm/wasm-pack/blob/master/CHANGELOG.md)

[原文](https://rustwasm.github.io/2018/09/24/the-biggest-wasm-pack-release-yet.html)


### JavaScript和WebAssembly函数调用性能提升

JavaScript和WebAssembly这两个语言之间函数调用是出了名的慢，但是最近这种情况已经得到了改善。在最新版本的Firefox Beta中，JS和WebAssembly之间的调用比非内联JS到JS函数调用要快。万岁！🎉

在最新的在Firefox Nightly工作中，一共优化了两个方向的调用从JavaScript到WebAssembly，从WebAssembly到JavaScript，而且还优化了WebAssembly调用内置函数的性能。

所有的优化都是为了减轻浏览器引擎的工作压力。这些改进一共分为两组：

-  减少登记（Reducing bookkeeping），减少了调用栈帧
- 切断中介（Cutting out intermediaries），函数调用采用尽可能直接的方式

一、如何优化WebAssembly到JavaScript的调用？

-  浏览器引擎需要处理的内容包含两种：字节码（解释器生成）和机器码（JIT生成），这就好比是两片独立的大陆
-  引擎需要在这两片「大陆」之间穿梭，以便统筹所有需要的信息。为了组织其工作，引擎有两个文件夹来记录这些信息。（比如SpiderMonkey引擎中，这些文件夹叫做activations）
- 每次切换到不同的「大陆」，引擎都会启用新的文件夹，问题是，要启动一个文件夹必须通过C++调用，这就增加了成本。
-  再最初增加WebAssembly支持的时候，相当于是给引擎增加了第三块「大陆」
-  所以，WebAssembly调用js的过程就多了两个阻碍： 创建了不必要的文件夹和增加了C++调用成本
-  优化手段： 将JIT-JS「大陆」和WebAssembly「大陆」合并在一起。

二、如何优化JavaScript到WebAssembly调用？

- 即便在JIT编译之后，js和webassembly都使用机器码，但还存在一些问题。比如调用js动态类型。
-  wasm是静态类型，不希望付出运行时开销，当js获取的参数是动态的，也就是说，它把参数放到堆内存（装箱），wasm不知道该如何处理它
- 所以在传给wasm之前，引擎会将装箱的参数值取出来，存到寄存器里，要做到这一点，还是需要C++。即便不需要C++，但这个过程也是没法取消的。
- 优化手段： （使用C++ stub 代码）去掉了「中介（trampoline）」，当javascript调用webassembly时，装箱的值就被取出来放到了合适的位置，等待wasm直接使用。

三、更快的JavaScript到WebAssembly调用：单态（Monomorphic）调用

单态调用是指每次都调用相同的函数。在js中，存在每次都使用完全相同类型的参数来调用该函数。如果可以编写代码以便JavaScript始终将相同的类型传递给相同的WebAssembly导出函数，那么您的调用将非常快。实际上，这些调用比许多JavaScript到JavaScript调用要快。

在未来，可能会为JavaScript添加内联WebAssemly的支持。

四、如何优化WebAssembly到内置函数的调用

内置函数是浏览器提供的函数，如Math.random。有些内置函数是JS本身实现的，这种叫做自托管。有些是C++实现的，不同的浏览器引擎，有不同的实现，这方面并不统一。如果是自托管的内置函数，WebAssembly调用的时候就能用到前面说的优化，但是遇到C++实现的函数，则又回到了解放前。为此，专门为这样的内置函数构建了一条特殊的直达「通道」，允许在WebAssembly调用C++实现的内置函数时，使用该特殊通道，增加性能。

目前只支持Math相关的内置函数，这是因为WebAssembly只支持整数和浮点数。但是对于dom处理等内置函数来说则效果不佳，因此调用相关函数的时候必须使用js，这就是wasm-bindgen所要做的。

但是WebAssembly的一些实验性支持类型也会逐渐登录浏览器，一旦这些类型稳定，那么WebAssembly就可以不经过js直接调用那些内置函数了。所以当前的优化工作，在未来也会适用于其他内置函数。

但是仍然有一些内置的函数需要使用js，这些函数的问题由host-bindings来解决。

以上。

[原文](https://hacks.mozilla.org/2018/10/calls-between-javascript-and-webassembly-are-finally-fast-%F0%9F%8E%89/)

### 使用WebAssembly加速Markdown渲染

SpiderOak公司的博文，SpiderOak是一个云端备份工具。该公司出了一个产品叫 Semaphor，它是可协作的加密群组IM软件。起因是因为SpiderOak团队需要一个安全的群组消息传递和文件共享解决方案，而没有电子邮件或现成协作工具带来的风险。 使用私有区块链加密开发。

在Semaphor中发送的每条消息，都是Markdown文档，所以渲染性能对它们来说很重要。所以他们一直在寻找加速渲染性能的方法。最终他们想到一个方案，就是将WebAssembly集成到React组件中，取代react函数，所以他们提出了[react-wasm-bridge](https://github.com/SpiderOak/react-wasm-bridge) 实验组件。它将props传递给Rust WebAssembly模块，并提供构建React渲染树的接口。

Rust是个很自然的选择，因为Rust工具链很完善，比如有wasm-bindgen这样的工具。他们对Markdown渲染器的要求是：

- 安全，解析用户的输入需要安全
- 快速， 呈现消息展示是Semaphor中最频繁的操作

Rust+wasm方案改进后

安全性：

当前他们的Markdown渲染器用的是[markdown-it](https://github.com/markdown-it/markdown-it)，它与react一起工作并不安全，因为包含有HTML字符串，对目前的解决方案并不满意。因此新的解决方案必须没有HTML字符串，而是直接创建元素。因此通过Rust来构建React 元素树，并且wasm环境还是一个天然的沙箱，对于攻击者来说并没有那么有用。

性能：

刚开始的实现方案性能并没有多少提升，后来针对它们的产品场景，将React中循环渲染构建dom的逻辑，转移到了Rust中，从而提升了性能。因为对于它们的产品来说，只需要渲染一次即可，im中的消息是不可变的，所以不需要重新渲染。

最终的测试结果：

```
BROWSER  MARKDOWN-IT   WASM
—————————————————------------
Firefox    162ms       175ms
Chrome     197ms       84ms
```

[react-markdown-wasm](https://github.com/SpiderOak/react-markdown-wasm)

[原文](https://engineering.spideroak.com/2018/08/29/using-webassembly-to-speed-up-message-rendering/)

### 通过WebAssembly在Cloudless上玩Serverless Rust

[Read](https://blog.cloudflare.com/cloudflare-workers-as-a-serverless-rust-platform/)

### 打通wasm <=> Fressian <=> cljs

通过Fressian，连通 Rust、wasm和cljs

Fressian是Clojure使用的数据格式， Fress是clojure.js实现的Fressian和wasm无缝转换的工具

现在用Rust实现serde-fressian，通过serde_fressian::wasm 模块与fress.wasm命名空间进行交互，这样就实现了使用Rust编写的wasm模块，直接为cljs使用。

[Read More](https://pkpkpk.github.io/wasm%E2%A5%AAfressian%E2%A5%ADcljs.html)

### 基于 AWS Lambda 和 WebAssembly实现Serverless Rust

这篇文章介绍了 ：

1. 介绍如何使用WebAssembly创建Serverless功能。
2. 演示完全用Rust编写的AWS Lambda函数。

[Read More](https://blog.scottlogic.com/2018/10/18/serverless-rust.html)



### 「官方」WebAssembly的后MVP时代：技能树如何发展「卡通版」

Mozilla工作人员 Lin Clark，最擅长的就是用卡通画来阐述技术思想，本篇就是他的新作。

他发现很多人误以为WebAssembly当前发布的MVP（minimum viable product ，最小可行产品）版本就是WebAssembly的最终版本。非也，非也。

事实上，WebAssembly还有很多能做的事情，目前大家掌握的只是技能树上的前几项。

1. mvp技能：

-  编译目标
-  快速执行
-  快速加载
-  线性内存

解锁成就： 在浏览器运行程序和游戏就像在本地机器上一样。

2. 更重量级的桌面应用，需要技能：

-  线程，已完成提案。
- SIMD， 已经在非常活跃的开发阶段。
- 64位地址， 有了一个好的计划。
- 流式编译， Firefox在2017年已经支持，其他浏览器还在努力。并且firefox在2017年也增加了用于分层编译的baseline编译器，其他浏览器也在过去一年中添加了相同的架构。
- 隐式HTTP缓存，就快登录Firefox了
- 其他改进，正在讨论

解锁成就：这些技能点实现以后，就会有更多重量级的应用程序进入浏览器。

3. 常规Web开发，需要与js互操的小模块，需要技能：

-  在js和wasm之间快速调用，目前在firefox已经解决了这个问题
-  快速简单的数据交换， reference types和host bindings 提案已经完成，Rust工具链已经创建了一些工具，可以自动为开发者处理这些数据交换，可以暂时弥补提案功能的缺席。
- ES模块集成，快要递交提案。
-  工具链集成， Rust的wasm-pack很不错。
- 向后兼容性， 利用wasm2js工具。

解锁成就：生态系统中将得到很多wasm和js互操作的模块

4. js框架与编译到js的语言

 一种路线是：用wasm重写现在的很多js框架，比如react、vue、ember等

另一种路线：编译到js的静态类型语言可以直接编译到wasm，比如scala.js、reason或elm

对于这两种路线，webassembly都需要支持更多高级技能：

- GC。 目前正在进行两项提案，JS的Typed Objects和WebAssembly的GC。Typed Objects可以描述对象的固定结构，WebAssembly GC可以直接访问该结构。有了这两个东东，js和wasm就可以共享js对象。这个估计得明年才能标准化，还不一定实现。
- 错误处理，处于研究和开发阶段。
- Debug， 目前浏览器的devtools有一点支持，但不理想。
- 尾调用支持，提案正在进行。

解锁成就： 达成js框架用wasm重写和编译到js的语言可以直接编译到wasm。

5. 浏览器之外。wasm要达成什么成就？

网络中除了网页，还有一个非常重要的属性：链接。互联网有链接才能互联，但是，目前用户跳转到的链接内容，都是和提供其服务的机器设备重度依赖的。一个网站是否要为每个可能的设备提供不同版本的代码？ 当然不是，一个网站的源码只有一个。这里面涉及一个概念：可移植性。

可移植性很好，你可以从不认识的人那里加载代码，不用管什么设备。但这里存在一个安全问题。利用wasm可以达成以下两点：

- 可移植性。向用户提供代码，并且可以在能运行浏览器的任何设备上执行。
- 安全沙箱。在wasm安全模型中运行代码，不会危机机器的安全。

所以可以将wasm视为浏览器工具箱中的一个独立的工具。比如，可以使用wasm对Node.js中的一些本地扩展进行重写，比如Node.js 中用C实现的一些模块，就没必要依赖于机器，这就增强了Node.js代码的可移植性。但是目前wasm还无法访问系统资源，因此还需要更多技能：

-  一个可移植的wasm系统接口，目前有一个package name maps的提案，可以用于将模块名称映射到加载模块的路径。这可能会得到浏览器和Node的支持，它们可以使用它来提供不同的路径，从而加载完全不同的模块，但使用相同的API。有了这个支持，就可以开始考虑接口的事了。这估计就需要更长的时间了。

6. CDN/ Serverless/ Edge计算（物联网）

这些领域为什么要使用WASM？

作者举个了例子， Fastly是一家提供CDN和边缘计算的公司，他们CTO如是说：wasm可以在安全、性能和规模上提供比系统进程更加强的功能。这就意味着需要一个新的技能：

-  运行时，执行实现一个wasm编译器或解释器。

目前CraneStation在建立一个通用的wasm运行时，[wasmtime](https://github.com/CraneStation/wasmtime)。

其他应用方向：

- 可移植的CLI工具，可以用于不同的操作系统
-  物联网
-  区块链， （这个原文没说）

长文预警！！！

[ Read More ](https://hacks.mozilla.org/2018/10/webassemblys-post-mvp-future/)

### Rust+Wasm写的视频特效 小应用

- [demo](https://mtharrison.github.io/wasmbooth/)
- [源码](https://github.com/mtharrison/wasmbooth)

![img](https://wx1.sinaimg.cn/mw690/71684decly1fqs7jl1w91j20ne0ps7wh.jpg)

## Retrofw 

### 在Travis-CI中使用自动部署构建多目标Rust

一个小型构建脚本（包括对代码的解释），可以为i86 32和64位计算机以及带有Travis-CI的Raspberry Pi（ARM）自动编译和创建Rust二进制文件。

[原文](https://medium.com/@tyrf/multi-target-rust-builds-with-auto-deployment-in-travis-ci-ab5214fb73ba)